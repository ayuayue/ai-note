<div class="article-layout">
    <div class="main-content">
        <article class="post">
            <header class="post-header">
                <h1 class="post-title">Mermaid 图表测试</h1>
                <div class="post-meta">
                    <div class="post-date">2025/8/22</div>
                    <div class="post-category">2025-08</div>
                </div>
            </header>
            <div class="warning">
                ⚠️ 注意：此内容由 AI 协助生成，准确性未经验证，请谨慎使用
            </div>
            <div class="post-content" id="post-content">
                <p>这是一个测试 Mermaid 图表功能的示例文档。</p>
<h2 id="流程图示例">流程图示例</h2>
<pre class="mermaid">graph TD
    A[开始] --&gt; B[初始化]
    B --&gt; C[处理数据]
    C --&gt; D[输出结果]
    D --&gt; E[结束]</pre>
<h2 id="序列图示例">序列图示例</h2>
<pre class="mermaid">sequenceDiagram
    participant 用户
    participant 系统
    用户-&gt;&gt;系统: 登录请求
    系统-&gt;&gt;用户: 验证通过
    用户-&gt;&gt;系统: 数据请求
    系统-&gt;&gt;用户: 返回数据</pre>
<h2 id="类图示例">类图示例</h2>
<pre class="mermaid">classDiagram
    Animal &lt;|-- Duck
    Animal &lt;|-- Fish
    Animal &lt;|-- Zebra
    Animal : +int age
    Animal : +String gender
    Animal: +isMammal()
    
    class Duck{
        +String beakColor
        +swim()
        +quack()
    }
    
    class Fish{
        -int sizeInFeet
        -canEat()
    }
    
    class Zebra{
        +bool is_wild
        +run()
    }</pre>
<h2 id="状态图示例">状态图示例</h2>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Still
    Still --&gt; [*]
    
    Still --&gt; Moving
    Moving --&gt; Still
    Moving --&gt; Crash
    Crash --&gt; [*]</pre>
<h2 id="饼图示例">饼图示例</h2>
<pre class="mermaid">pie title 2025年技术趋势分布
    &quot;人工智能&quot; : 42.86
    &quot;云计算&quot; : 14.29
    &quot;大数据&quot; : 14.29
    &quot;物联网&quot; : 14.29
    &quot;区块链&quot; : 14.29</pre>
<h2 id="甘特图示例">甘特图示例</h2>
<pre class="mermaid">gantt
    title 项目开发计划
    dateFormat  YYYY-MM-DD
    section 设计
    需求分析           :done,    des1, 2025-01-06,2025-01-08
    原型设计           :active,  des2, 2025-01-09, 3d
    UI设计            :         des3, after des2, 5d
    section 开发
    前端开发           :2025-01-12, 10d
    后端开发           :2025-01-15, 12d</pre>
<h2 id="实体关系图示例">实体关系图示例</h2>
<pre class="mermaid">erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--|{ LINE-ITEM : contains
    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses</pre>
<h2 id="spring框架核心组件uml类图">spring框架核心组件UML类图</h2>
<pre class="mermaid">classDiagram
    direction TB

    %% --- 顶层结构 ---
    class JVM {
        &lt;&lt;JVM Memory Model&gt;&gt;
    }

    class ThreadPrivateArea {
        &lt;&lt;Thread-Private Area&gt;&gt;
        + Program Counter (PC) Register
        + JVM Stack
        + Native Method Stack
    }

    class ThreadSharedArea {
        &lt;&lt;Thread-Shared Area&gt;&gt;
    }

    JVM *-- ThreadPrivateArea : contains
    JVM *-- ThreadSharedArea : contains

    %% --- 线程共享区分解 ---
    class Heap {
        &lt;&lt;Heap&gt;&gt;
        + Stores all object instances
    }

    class Metaspace {
        &lt;&lt;Metaspace / Permanent Generation (pre-JDK8)&gt;&gt;
        + Stores class metadata
        + Stores static variables
        + Runtime constant pool
    }

    ThreadSharedArea *-- Heap : contains
    ThreadSharedArea *-- Metaspace : contains

    %% --- 堆内存分解 ---
    class YoungGeneration {
        &lt;&lt;Young Generation&gt;&gt;
    }

    class OldGeneration {
        &lt;&lt;Old Generation&gt;&gt;
        + Stores long-lived objects
        + Stores large objects
    }

    Heap *-- YoungGeneration : composed of
    Heap *-- OldGeneration : composed of

    %% --- 年轻代分解 ---
    class EdenSpace {
        &lt;&lt;Eden Space&gt;&gt;
        + Where new objects are allocated
    }

    class SurvivorSpace {
        &lt;&lt;Survivor Space (S0 &amp; S1)&gt;&gt;
        + Stores objects surviving Minor GC
    }

    YoungGeneration *-- EdenSpace : composed of
    YoungGeneration *-- SurvivorSpace : composed of</pre>
<pre class="mermaid">timeline
    title 大模型发展史
    section 萌芽期 (2017-2018)
        Transformer架构提出 : 2017: Vaswani等提出自注意力机制
        GPT-1诞生 : 2018: OpenAI发布1.17亿参数模型
    section 快速发展期 (2019-2020)
        BERT崛起 : 2019: Google提出双向Transformer
        GPT-3突破 : 2020: 1750亿参数模型问世
    section 多模态时代 (2021-2022)
        CLIP模型 : 2021: 图文跨模态理解
        ChatGPT发布 : 2022: 对话能力突破
    section 生态竞争期 (2023-)
        开源模型爆发 : LLaMA/PaLM等竞品
        多模态大模型 : GPT-4V/Gemini</pre>

            </div>
        </article>
    </div>
    <aside class="toc-sidebar" id="toc-sidebar">
        <div class="toc-header">
            <h3>文章目录</h3>
        </div>
        <nav class="toc-nav" id="toc-nav">
            <!-- 目录内容将通过JavaScript自动生成 -->
        </nav>
    </aside>
</div>

<script>
    // Add copy buttons to code blocks
    function addCopyButtons() {
        const sourceCodeBlocks = document.querySelectorAll('.sourceCode');
        sourceCodeBlocks.forEach(function(block) {
            if (block.querySelector('.copy-button')) return;
            const preElement = block.querySelector('pre');
            if (!preElement) return;

            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = '复制';
            button.setAttribute('aria-label', '复制代码');

            button.addEventListener('click', function() {
                const code = preElement.querySelector('code');
                const text = code ? code.innerText : preElement.innerText;

                navigator.clipboard.writeText(text).then(function() {
                    button.textContent = '已复制';
                    button.classList.add('copied');

                    setTimeout(function() {
                        button.textContent = '复制';
                        button.classList.remove('copied');
                    }, 3000);
                }).catch(function(err) {
                    console.error('复制失败: ', err);
                    button.textContent = '失败';
                    setTimeout(function() {
                        button.textContent = '复制';
                    }, 3000);
                });
            });

            block.appendChild(button);
        });

        const allPreBlocks = document.querySelectorAll('pre:not(.mermaid)');
        allPreBlocks.forEach(function(block) {
            if (block.closest('.sourceCode') || block.querySelector('.copy-button')) return;

            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = '复制';
            button.setAttribute('aria-label', '复制代码');

            button.addEventListener('click', function() {
                const code = block.querySelector('code');
                const text = code ? code.innerText : block.innerText;

                navigator.clipboard.writeText(text).then(function() {
                    button.textContent = '已复制';
                    button.classList.add('copied');

                    setTimeout(function() {
                        button.textContent = '复制';
                        button.classList.remove('copied');
                    }, 3000);
                }).catch(function(err) {
                    console.error('复制失败: ', err);
                    button.textContent = '失败';
                    setTimeout(function() {
                        button.textContent = '复制';
                    }, 3000);
                });
            });

            block.appendChild(button);
        });
    }

    // 生成文章目录
    function generateTableOfContents() {
        const postContent = document.getElementById('post-content');
        const tocNav = document.getElementById('toc-nav');
        
        if (!postContent || !tocNav) return;
        
        // 查找所有标题元素
        const headings = postContent.querySelectorAll('h1, h2, h3, h4, h5, h6');
        if (headings.length === 0) {
            // 如果没有标题，隐藏目录
            document.getElementById('toc-sidebar').style.display = 'none';
            return;
        }
        
        // 创建目录结构
        const tocList = document.createElement('ul');
        tocList.className = 'toc-list';
        
        let currentLevel = 1;
        let currentList = tocList;
        let listStack = [tocList];
        
        headings.forEach((heading, index) => {
            // 强制为每个标题设置标准化的ID（始终重写现有ID）
            const normalizedId = 'heading-' + index;
            heading.id = normalizedId;
            
            const level = parseInt(heading.tagName.charAt(1));
            const title = heading.textContent.trim();
            
            // 创建目录项
            const tocItem = document.createElement('li');
            tocItem.className = 'toc-item toc-level-' + level;
            
            const tocLink = document.createElement('a');
            tocLink.href = 'javascript:void(0)'; // 避免触发路由
            tocLink.setAttribute('data-target', heading.id); // 存储目标ID
            tocLink.textContent = title;
            tocLink.className = 'toc-link';
            
            tocItem.appendChild(tocLink);
            
            // 处理层级关系
            if (level > currentLevel) {
                // 创建新的子列表
                const newList = document.createElement('ul');
                newList.className = 'toc-sublist';
                // 检查是否有父元素
                const parentList = listStack[listStack.length - 1];
                if (parentList.lastElementChild) {
                    parentList.lastElementChild.appendChild(newList);
                } else {
                    // 如果没有父元素，直接添加到当前列表
                    parentList.appendChild(newList);
                }
                listStack.push(newList);
                currentList = newList;
            } else if (level < currentLevel) {
                // 返回到上一级
                while (listStack.length > level) {
                    listStack.pop();
                }
                currentList = listStack[listStack.length - 1];
            }
            
            currentList.appendChild(tocItem);
            currentLevel = level;
        });
        
        tocNav.appendChild(tocList);
        
        // 高亮当前章节
        highlightCurrentSection();
        
        // 滚动监听
        window.addEventListener('scroll', highlightCurrentSection);
        
        // 为目录链接添加点击事件
        setTimeout(() => {
            const tocLinks = document.querySelectorAll('.toc-link');
            tocLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute('data-target');
                    if (targetId) {
                        const targetElement = document.getElementById(targetId);
                        if (targetElement) {
                            targetElement.scrollIntoView({ 
                                behavior: 'smooth', 
                                block: 'start',
                                inline: 'nearest'
                            });
                        }
                    }
                });
            });
        }, 200); // 延迟确保目录已生成
    }
    
    // 高亮当前阅读的章节
    function highlightCurrentSection() {
        const headings = document.querySelectorAll('.post-content h1, .post-content h2, .post-content h3, .post-content h4, .post-content h5, .post-content h6');
        const tocLinks = document.querySelectorAll('.toc-link');
        
        let currentHeading = null;
        const scrollPosition = window.pageYOffset + 100;
        
        // 找到当前可见的标题
        for (let i = headings.length - 1; i >= 0; i--) {
            if (headings[i].offsetTop <= scrollPosition) {
                currentHeading = headings[i];
                break;
            }
        }
        
        // 清除所有活动状态
        tocLinks.forEach(link => link.classList.remove('active'));
        
        // 高亮当前章节
        if (currentHeading) {
            const activeLink = document.querySelector('.toc-link[href="#' + currentHeading.id + '"]');
            if (activeLink) {
                activeLink.classList.add('active');
            }
        }
    }

    // Initialize copy buttons and TOC after content loads
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            addCopyButtons();
            setTimeout(generateTableOfContents, 100); // 延迟生成以确保内容已加载
        });
    } else {
        addCopyButtons();
        setTimeout(generateTableOfContents, 100);
    }
</script>