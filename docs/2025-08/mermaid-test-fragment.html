<style>
    .toc-sidebar {
        position: sticky;
        float: right;
        width: 280px;
        max-height: calc(100vh - 150px);
        overflow-y: auto;
        margin: 0 0 20px 30px;
        padding: 15px;
        background: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-size: 0.9rem;
        z-index: 10;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .toc-sidebar-title {
        font-weight: bold;
        margin-bottom: 12px;
        padding-bottom: 10px;
        border-bottom: 2px solid var(--secondary-color);
        font-size: 0.95rem;
    }

    .toc-sidebar ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    .toc-sidebar ul ul {
        margin: 0;
        padding-left: 16px;
    }

    .toc-sidebar li {
        margin: 8px 0;
    }

    .toc-sidebar a {
        color: var(--secondary-color);
        text-decoration: none;
        transition: color 0.2s;
        font-weight: 500;
    }

    .toc-sidebar a:hover {
        color: var(--accent-color);
        text-decoration: underline;
    }

    .toc-sidebar::-webkit-scrollbar {
        width: 6px;
    }

    .toc-sidebar::-webkit-scrollbar-track {
        background: transparent;
    }

    .toc-sidebar::-webkit-scrollbar-thumb {
        background: var(--secondary-color);
        border-radius: 3px;
    }

    .toc-sidebar::-webkit-scrollbar-thumb:hover {
        background: var(--accent-color);
    }

    @media (max-width: 1200px) {
        .toc-sidebar {
            display: none !important;
        }
    }
</style>

<article class="post">
    <header class="post-header">
        <h1 class="post-title">Mermaid 图表测试</h1>
        <div class="post-meta">
            <div class="post-date">2025/8/24</div>
            <div class="post-category">2025-08</div>
        </div>
    </header>
    <div class="warning">
        ⚠️ 注意：此内容由 AI 协助生成，准确性未经验证，请谨慎使用
    </div>
    <div class="toc-sidebar" id="toc-container" style="display: none;">
        <div class="toc-sidebar-title">目录</div>
        <div id="toc-content"></div>
    </div>
    <div class="post-content" id="post-content">
        <h1 id="mermaid-图表测试">Mermaid 图表测试</h1>
<p>这是一个测试 Mermaid 图表功能的示例文档。</p>
<h2 id="流程图示例">流程图示例</h2>
<pre class="mermaid">graph TD
    A[开始] --&gt; B[初始化]
    B --&gt; C[处理数据]
    C --&gt; D[输出结果]
    D --&gt; E[结束]</pre>
<h2 id="序列图示例">序列图示例</h2>
<pre class="mermaid">sequenceDiagram
    participant 用户
    participant 系统
    用户-&gt;&gt;系统: 登录请求
    系统-&gt;&gt;用户: 验证通过
    用户-&gt;&gt;系统: 数据请求
    系统-&gt;&gt;用户: 返回数据</pre>
<h2 id="类图示例">类图示例</h2>
<pre class="mermaid">classDiagram
    Animal &lt;|-- Duck
    Animal &lt;|-- Fish
    Animal &lt;|-- Zebra
    Animal : +int age
    Animal : +String gender
    Animal: +isMammal()
    
    class Duck{
        +String beakColor
        +swim()
        +quack()
    }
    
    class Fish{
        -int sizeInFeet
        -canEat()
    }
    
    class Zebra{
        +bool is_wild
        +run()
    }</pre>
<h2 id="状态图示例">状态图示例</h2>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Still
    Still --&gt; [*]
    
    Still --&gt; Moving
    Moving --&gt; Still
    Moving --&gt; Crash
    Crash --&gt; [*]</pre>
<h2 id="饼图示例">饼图示例</h2>
<pre class="mermaid">pie title 2025年技术趋势分布
    &quot;人工智能&quot; : 42.86
    &quot;云计算&quot; : 14.29
    &quot;大数据&quot; : 14.29
    &quot;物联网&quot; : 14.29
    &quot;区块链&quot; : 14.29</pre>
<h2 id="甘特图示例">甘特图示例</h2>
<pre class="mermaid">gantt
    title 项目开发计划
    dateFormat  YYYY-MM-DD
    section 设计
    需求分析           :done,    des1, 2025-01-06,2025-01-08
    原型设计           :active,  des2, 2025-01-09, 3d
    UI设计            :         des3, after des2, 5d
    section 开发
    前端开发           :2025-01-12, 10d
    后端开发           :2025-01-15, 12d</pre>
<h2 id="实体关系图示例">实体关系图示例</h2>
<pre class="mermaid">erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--|{ LINE-ITEM : contains
    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses</pre>
<h2 id="spring框架核心组件uml类图">spring框架核心组件UML类图</h2>
<pre class="mermaid">classDiagram
    direction TB

    %% --- 顶层结构 ---
    class JVM {
        &lt;&lt;JVM Memory Model&gt;&gt;
    }

    class ThreadPrivateArea {
        &lt;&lt;Thread-Private Area&gt;&gt;
        + Program Counter (PC) Register
        + JVM Stack
        + Native Method Stack
    }

    class ThreadSharedArea {
        &lt;&lt;Thread-Shared Area&gt;&gt;
    }

    JVM *-- ThreadPrivateArea : contains
    JVM *-- ThreadSharedArea : contains

    %% --- 线程共享区分解 ---
    class Heap {
        &lt;&lt;Heap&gt;&gt;
        + Stores all object instances
    }

    class Metaspace {
        &lt;&lt;Metaspace / Permanent Generation (pre-JDK8)&gt;&gt;
        + Stores class metadata
        + Stores static variables
        + Runtime constant pool
    }

    ThreadSharedArea *-- Heap : contains
    ThreadSharedArea *-- Metaspace : contains

    %% --- 堆内存分解 ---
    class YoungGeneration {
        &lt;&lt;Young Generation&gt;&gt;
    }

    class OldGeneration {
        &lt;&lt;Old Generation&gt;&gt;
        + Stores long-lived objects
        + Stores large objects
    }

    Heap *-- YoungGeneration : composed of
    Heap *-- OldGeneration : composed of

    %% --- 年轻代分解 ---
    class EdenSpace {
        &lt;&lt;Eden Space&gt;&gt;
        + Where new objects are allocated
    }

    class SurvivorSpace {
        &lt;&lt;Survivor Space (S0 &amp; S1)&gt;&gt;
        + Stores objects surviving Minor GC
    }

    YoungGeneration *-- EdenSpace : composed of
    YoungGeneration *-- SurvivorSpace : composed of</pre>
<pre class="mermaid">timeline
    title 大模型发展史
    section 萌芽期 (2017-2018)
        Transformer架构提出 : 2017: Vaswani等提出自注意力机制
        GPT-1诞生 : 2018: OpenAI发布1.17亿参数模型
    section 快速发展期 (2019-2020)
        BERT崛起 : 2019: Google提出双向Transformer
        GPT-3突破 : 2020: 1750亿参数模型问世
    section 多模态时代 (2021-2022)
        CLIP模型 : 2021: 图文跨模态理解
        ChatGPT发布 : 2022: 对话能力突破
    section 生态竞争期 (2023-)
        开源模型爆发 : LLaMA/PaLM等竞品
        多模态大模型 : GPT-4V/Gemini</pre>

    </div>
</article>

<script>
    // Build table of contents
    function buildTableOfContents() {
        const postContent = document.getElementById('post-content');
        const tocContainer = document.getElementById('toc-container');
        const tocContent = document.getElementById('toc-content');

        if (!postContent || !tocContainer || !tocContent) {
            return;
        }

        const headings = postContent.querySelectorAll('h2, h3, h4');
        if (headings.length === 0) {
            return;
        }

        // Assign IDs to headings
        headings.forEach((heading, index) => {
            if (!heading.id) {
                heading.id = `h-${index}`;
            }
        });

        // Build TOC items
        let tocItems = [];
        headings.forEach((heading) => {
            const level = parseInt(heading.tagName[1]);
            const text = heading.textContent.trim();
            tocItems.push({
                level: level,
                id: heading.id,
                text: text
            });
        });

        // Generate TOC HTML
        let tocHTML = '<ul>';
        let lastLevel = 1;

        tocItems.forEach((item) => {
            if (item.level > lastLevel) {
                for (let i = lastLevel; i < item.level; i++) {
                    tocHTML += '<ul>';
                }
            } else if (item.level < lastLevel) {
                for (let i = item.level; i < lastLevel; i++) {
                    tocHTML += '</li></ul>';
                }
                tocHTML += '</li>';
            } else if (lastLevel > 1) {
                tocHTML += '</li>';
            }

            tocHTML += `<li><a href="#${item.id}">${item.text}</a>`;
            lastLevel = item.level;
        });

        for (let i = 1; i < lastLevel; i++) {
            tocHTML += '</li></ul>';
        }
        if (lastLevel > 1) {
            tocHTML += '</li>';
        }
        tocHTML += '</ul>';

        tocContent.innerHTML = tocHTML;
        tocContainer.style.display = 'block';

        // Add click handlers to TOC links
        tocContent.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
    }

    // Add copy buttons to code blocks
    function addCopyButtons() {
        const sourceCodeBlocks = document.querySelectorAll('.sourceCode');
        sourceCodeBlocks.forEach(function(block) {
            if (block.querySelector('.copy-button')) return;
            const preElement = block.querySelector('pre');
            if (!preElement) return;

            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = '复制';
            button.setAttribute('aria-label', '复制代码');

            button.addEventListener('click', function() {
                const code = preElement.querySelector('code');
                const text = code ? code.innerText : preElement.innerText;

                navigator.clipboard.writeText(text).then(function() {
                    button.textContent = '已复制';
                    button.classList.add('copied');

                    setTimeout(function() {
                        button.textContent = '复制';
                        button.classList.remove('copied');
                    }, 3000);
                }).catch(function(err) {
                    console.error('复制失败: ', err);
                    button.textContent = '失败';
                    setTimeout(function() {
                        button.textContent = '复制';
                    }, 3000);
                });
            });

            block.appendChild(button);
        });

        const allPreBlocks = document.querySelectorAll('pre:not(.mermaid)');
        allPreBlocks.forEach(function(block) {
            if (block.closest('.sourceCode') || block.querySelector('.copy-button')) return;

            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = '复制';
            button.setAttribute('aria-label', '复制代码');

            button.addEventListener('click', function() {
                const code = block.querySelector('code');
                const text = code ? code.innerText : block.innerText;

                navigator.clipboard.writeText(text).then(function() {
                    button.textContent = '已复制';
                    button.classList.add('copied');

                    setTimeout(function() {
                        button.textContent = '复制';
                        button.classList.remove('copied');
                    }, 3000);
                }).catch(function(err) {
                    console.error('复制失败: ', err);
                    button.textContent = '失败';
                    setTimeout(function() {
                        button.textContent = '复制';
                    }, 3000);
                });
            });

            block.appendChild(button);
        });
    }

    // Initialize TOC and copy buttons after content loads
    window.addEventListener('load', function() {
        buildTableOfContents();
        addCopyButtons();
    });

    // Also call buildTableOfContents immediately in case content is already loaded
    document.addEventListener('DOMContentLoaded', function() {
        buildTableOfContents();
        addCopyButtons();
    });
</script>
