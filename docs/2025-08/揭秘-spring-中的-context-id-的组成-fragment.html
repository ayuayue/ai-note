<style>
    /* CSS Variables for fragment */
    :root {
        --primary-color: #2c3e50;
        --secondary-color: #3498db;
        --bg-color: #f8f9fa;
        --text-color: #34495e;
        --border-color: #e9ecef;
        --card-bg: #ffffff;
    }

    /* TOC Sidebar Styles */
    .article-layout {
        display: flex;
        max-width: 1400px;
        margin: 0 auto;
        gap: 30px;
        padding: 0 20px;
    }

    .main-content {
        flex: 1;
        min-width: 0;
    }

    .toc-sidebar {
        width: 280px;
        flex-shrink: 0;
        position: sticky;
        top: 20px;
        height: fit-content;
        max-height: calc(100vh - 40px);
        overflow-y: auto;
        background: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    }

    .toc-header h3 {
        margin: 0 0 15px 0;
        font-size: 1.1rem;
        color: var(--primary-color);
        border-bottom: 2px solid var(--secondary-color);
        padding-bottom: 10px;
    }

    .toc-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    .toc-item {
        margin-bottom: 8px;
    }

    .toc-link {
        display: block;
        padding: 6px 10px;
        color: var(--text-color);
        text-decoration: none;
        border-radius: 4px;
        transition: all 0.2s ease;
        font-size: 0.95rem;
    }

    .toc-link:hover {
        background: var(--secondary-color);
        color: white;
        padding-left: 15px;
    }

    .toc-link.active {
        background: var(--secondary-color);
        color: white;
        font-weight: 500;
    }

    .toc-sublist {
        list-style: none;
        padding-left: 20px;
        margin-top: 5px;
    }

    .toc-sublist .toc-link {
        font-size: 0.9rem;
        opacity: 0.9;
    }

    /* Post Styles */
    .post {
        background: var(--card-bg);
        border-radius: 8px;
        padding: 30px;
        margin-bottom: 30px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        border: 1px solid var(--border-color);
    }

    .post-header {
        margin-bottom: 25px;
        padding-bottom: 20px;
        border-bottom: 1px solid var(--border-color);
    }

    .post-title {
        color: var(--primary-color);
        font-size: 2rem;
        margin-bottom: 15px;
    }

    .post-meta {
        display: flex;
        gap: 15px;
        align-items: center;
        font-size: 0.95rem;
        color: #6c757d;
    }

    .post-date {
        background-color: #e3f2fd;
        color: var(--secondary-color);
        padding: 5px 15px;
        border-radius: 20px;
        font-weight: 500;
    }

    .post-category {
        background-color: #e8f5e9;
        color: #4caf50;
        padding: 5px 15px;
        border-radius: 20px;
        font-weight: 500;
    }

    .warning {
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
        color: #856404;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 30px;
        text-align: center;
        font-size: 0.9rem;
    }

    .post-content {
        font-size: 1.05rem;
        line-height: 1.7;
        color: var(--text-color);
    }

    .post-content h1, .post-content h2, .post-content h3,
    .post-content h4, .post-content h5, .post-content h6 {
        color: var(--primary-color);
        margin-top: 35px;
        margin-bottom: 20px;
        scroll-margin-top: 20px;
    }

    .post-content h2 {
        font-size: 1.5rem;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--border-color);
    }

    .post-content h3 {
        font-size: 1.3rem;
        color: #2980b9;
    }

    .post-content p {
        margin-bottom: 18px;
    }

    .post-content code {
        background-color: #e8eaed;
        padding: 3px 7px;
        border-radius: 4px;
        font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        color: #c0392b;
        font-size: 0.9em;
    }

    .post-content pre {
        background-color: #2d2d2d;
        color: #f8f8f2;
        padding: 20px;
        border-radius: 8px;
        overflow-x: auto;
        margin: 25px 0;
        font-size: 0.9em;
        line-height: 1.5;
        position: relative;
    }

    .post-content pre code {
        background-color: transparent;
        padding: 0;
        color: inherit;
    }

    .copy-button {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: white;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.85rem;
        transition: all 0.3s ease;
        backdrop-filter: blur(5px);
    }

    .copy-button:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.5);
    }

    .copy-button.copied {
        background: #4caf50;
        border-color: #4caf50;
    }

    /* Responsive */
    @media (max-width: 1024px) {
        .article-layout {
            flex-direction: column;
        }

        .toc-sidebar {
            width: 100%;
            position: static;
            max-height: none;
        }
    }

    @media (max-width: 768px) {
        .post {
            padding: 20px;
        }

        .post-title {
            font-size: 1.6rem;
        }

        .post-content {
            font-size: 1rem;
        }

        .article-layout {
            padding: 0 15px;
        }
    }
</style>

<div class="article-layout">
    <div class="main-content">
        <article class="post">
            <header class="post-header">
                <h1 class="post-title">揭秘-spring-中的-context-id-的组成</h1>
                <div class="post-meta">
                    <div class="post-date">2025/8/22</div>
                    <div class="post-category">2025-08</div>
                </div>
            </header>
            <div class="warning">
                ⚠️ 注意：此内容由 AI 协助生成，准确性未经验证，请谨慎使用
            </div>
            <div class="post-content" id="post-content">
                <h2 id="揭秘-spring-中的-符号classnamehashcode-字符串的由来">揭秘 Spring
中的 <code>@</code> 符号：<code>ClassName@HashCode</code>
字符串的由来</h2>
<p>作为 Spring 开发者，你一定对下面这种输出格式非常熟悉：</p>
<pre><code>org.springframework.context.annotation.AnnotationConfigApplicationContext@1e643faf</code></pre>
<p>当我们尝试打印一个 Spring
容器（<code>ApplicationContext</code>）或其他 Spring 管理的 Bean
时，经常会看到这种由 <code>类全限定名</code> + <code>@</code> +
<code>十六进制字符串</code> 组成的输出。</p>
<p>很多初学者可能会疑惑：<code>1e643faf</code> 是什么？是我在哪里配置的
ID 吗？为什么每次运行程序，这个值都不一样？</p>
<p>今天，我们就来追根溯源，彻底搞清楚这个字符串的由来以及它背后体现的框架设计思想。</p>
<h3 id="最初的猜想是-object.tostring-吗">最初的猜想：是
<code>Object.toString()</code> 吗？</h3>
<p>Java 程序员的直觉会告诉我们，这看起来非常像
<code>java.lang.Object</code> 类的默认 <code>toString()</code>
方法的输出。让我们回顾一下 <code>Object.toString()</code>
的经典实现：</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="bu">String</span> <span class="fu">toString</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">getClass</span><span class="op">().</span><span class="fu">getName</span><span class="op">()</span> <span class="op">+</span> <span class="st">&quot;@&quot;</span> <span class="op">+</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">toHexString</span><span class="op">(</span><span class="fu">hashCode</span><span class="op">());</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>这个实现和我们在 Spring 中看到的输出格式几乎一模一样！它由
<strong>类名</strong> 和
<strong>对象的哈希码（hashCode）的十六进制表示</strong> 组成。</p>
<p>那么，Spring
是直接使用了这个默认方法吗？答案是：<strong>不完全是，但更进了一步。</strong></p>
<h3 id="深入源码spring-的-objectutils-工具类">深入源码：Spring 的
<code>ObjectUtils</code> 工具类</h3>
<p>通过分析 Spring 的源码，我们会发现，很多 Spring
内部组件在需要打印对象标识时，会使用一个名为 <code>ObjectUtils</code>
的工具类。这个类中有一个关键方法 <code>identityToString()</code>。</p>
<p>这正是我们文章开头用户提问的那段源码：</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 位于 org.springframework.util.ObjectUtils 类中</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">static</span> <span class="bu">String</span> <span class="fu">identityToString</span><span class="op">(</span><span class="at">@Nullable</span> <span class="bu">Object</span> obj<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>obj <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> obj<span class="op">.</span><span class="fu">getClass</span><span class="op">().</span><span class="fu">getName</span><span class="op">()</span> <span class="op">+</span> <span class="st">&quot;@&quot;</span> <span class="op">+</span> <span class="fu">getIdentityHexString</span><span class="op">(</span>obj<span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">static</span> <span class="bu">String</span> <span class="fu">getIdentityHexString</span><span class="op">(</span><span class="bu">Object</span> obj<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">toHexString</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">identityHashCode</span><span class="op">(</span>obj<span class="op">));</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>可以看到，<code>identityToString</code> 的结构与
<code>Object.toString()</code>
非常相似，但它在获取哈希码时，并没有直接调用
<code>obj.hashCode()</code>，而是调用了
<code>System.identityHashCode(obj)</code>。</p>
<p><strong>这一个微小但至关重要的区别，正是 Spring
框架严谨性的体现。</strong></p>
<h3
id="核心解惑hashcode-vs-system.identityhashcode">核心解惑：<code>hashCode()</code>
vs <code>System.identityHashCode()</code></h3>
<p>要理解 Spring 的良苦用心，我们必须弄清楚这两个方法的本质区别。</p>
<h4 id="obj.hashcode"><code>obj.hashCode()</code></h4>
<ul>
<li><strong>可被重写 (Overridable)</strong>：任何类都可以重写
<code>hashCode()</code> 方法。</li>
<li><strong>关注“逻辑相等”</strong>：它的设计初衷是为了配合
<code>equals()</code> 方法，服务于
<code>HashMap</code>、<code>HashSet</code>
等集合。约定要求：如果两个对象 <code>equals()</code> 相等，那么它们的
<code>hashCode()</code> 必须相等。</li>
<li><strong>示例</strong>：两个内容同为 “hello” 的 <code>String</code>
对象，即使是内存中两个独立的实例，它们的 <code>hashCode()</code>
值也一定是相同的。</li>
</ul>
<h4
id="system.identityhashcodeobj"><code>System.identityHashCode(obj)</code></h4>
<ul>
<li><strong>不可重写</strong>：这是一个静态方法，其行为无法被任何类修改。</li>
<li><strong>关注“实例身份”</strong>：它无视任何类对
<code>hashCode()</code>
的重写，返回的是对象最“原始”的哈希码，这个值通常根据对象的内存地址计算得出。可以理解为它返回的是
<code>Object.hashCode()</code> 未被重写时的那个版本的值。</li>
<li><strong>保证唯一性</strong>：只要两个引用指向的不是内存中的同一个对象实例，那么
<code>System.identityHashCode()</code> 返回的值就几乎肯定是不同的。</li>
</ul>
<h3 id="使用-mermaid-图来理解流程">使用 Mermaid 图来理解流程</h3>
<p>下面这张图清晰地展示了默认 <code>toString()</code> 和 Spring
<code>identityToString()</code> 在生成哈希码时的不同路径。</p>
<pre class="mermaid">graph TD
    subgraph 对象字符串表示的两种方式

        A[打印 Object obj] --&gt; B{选择实现方式};

        B -- &quot;默认: obj.toString()&quot; --&gt; C[&quot;调用 obj.hashCode()&quot;];
        B -- &quot;Spring: ObjectUtils.identityToString(obj)&quot; --&gt; D[&quot;调用 System.identityHashCode(obj)&quot;];

        C --&gt; E{&lt;font color=red&gt;可能被子类重写&lt;/font&gt;};
        D --&gt; F{&lt;font color=green&gt;无法被重写, 保证实例唯一性&lt;/font&gt;};

        subgraph 共同的后续步骤
            G[&quot;Integer.toHexString(...) &lt;br&gt; 转换为十六进制&quot;] --&gt; H[&quot;obj.getClass().getName() + &#39;@&#39; + ... &lt;br&gt; 拼接最终字符串&quot;];
        end

        E --&gt; G;
        F --&gt; G;
        
    end

    style C fill:#ECECFF,stroke:#333,stroke-width:2px
    style D fill:#ECECFF,stroke:#333,stroke-width:2px</pre>
<h3 id="为什么-spring-要这样做">为什么 Spring 要这样做？</h3>
<p>答案是：<strong>为了日志记录和调试的明确性与可靠性。</strong></p>
<p>在复杂的应用程序中，我们经常需要通过日志来追踪对象的行为。想象一下，如果有一个自定义类，它为了业务逻辑重写了
<code>hashCode()</code> 和 <code>equals()</code> 方法。</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MyConfig <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="bu">String</span> name<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... equals() 和 hashCode() 都基于 name 属性实现</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>MyConfig config1 <span class="op">=</span> <span class="kw">new</span> <span class="fu">MyConfig</span><span class="op">(</span><span class="st">&quot;prod&quot;</span><span class="op">);</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>MyConfig config2 <span class="op">=</span> <span class="kw">new</span> <span class="fu">MyConfig</span><span class="op">(</span><span class="st">&quot;prod&quot;</span><span class="op">);</span> </span></code></pre></div>
<p>此时，<code>config1</code> 和 <code>config2</code>
是内存中两个完全不同的实例。</p>
<ul>
<li>如果使用 <code>config1.hashCode()</code> 和
<code>config2.hashCode()</code>，你会得到<strong>相同的值</strong>。在日志中，你将无法区分
<code>MyConfig@xxxx</code> 到底指的是 <code>config1</code> 还是
<code>config2</code>。</li>
<li>如果使用 <code>System.identityHashCode(config1)</code> 和
<code>System.identityHashCode(config2)</code>，你会得到<strong>不同的值</strong>。在日志中，你可以清晰地追踪每一个独立实例的生命周期，极大地提升了调试效率。</li>
</ul>
<p>Spring
作为一个基础框架，必须保证其日志和内部状态的输出是绝对清晰、无歧义的。通过
<code>System.identityHashCode()</code>，Spring
确保了它打印出的对象标识符反映的是对象在内存中的<strong>物理身份</strong>，而非其<strong>逻辑内容</strong>。</p>
<h3 id="总结">总结</h3>
<p>下次当你在控制台或日志文件中看到 <code>ClassName@HashCode</code>
这样的字符串时，你可以自信地知道：</p>
<ol type="1">
<li>它<strong>不是一个配置的 ID</strong>，而是对象的内存标识符。</li>
<li>它是由 Spring 的 <code>ObjectUtils.identityToString()</code>
方法生成的，而非 Java 默认的 <code>Object.toString()</code>。</li>
<li><code>@</code> 后面的十六进制串是通过
<code>System.identityHashCode()</code>
计算得来的，这保证了每个不同的对象实例都有一个唯一的标识，是框架为了<strong>调试和日志的严谨性</strong>而做出的精心设计。</li>
</ol>
<p>这个小小的细节，恰恰体现了 Spring
框架在设计上的深思熟虑和对开发者体验的极致追求。</p>

            </div>
        </article>
    </div>
    <aside class="toc-sidebar" id="toc-sidebar">
        <div class="toc-header">
            <h3>文章目录</h3>
        </div>
        <nav class="toc-nav" id="toc-nav">
            <!-- 目录内容将通过JavaScript自动生成 -->
        </nav>
    </aside>
</div>

<script>
    // Add copy buttons to code blocks
    function addCopyButtons() {
        const sourceCodeBlocks = document.querySelectorAll('.sourceCode');
        sourceCodeBlocks.forEach(function(block) {
            if (block.querySelector('.copy-button')) return;
            const preElement = block.querySelector('pre');
            if (!preElement) return;

            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = '复制';
            button.setAttribute('aria-label', '复制代码');

            button.addEventListener('click', function() {
                const code = preElement.querySelector('code');
                const text = code ? code.innerText : preElement.innerText;

                navigator.clipboard.writeText(text).then(function() {
                    button.textContent = '已复制';
                    button.classList.add('copied');

                    setTimeout(function() {
                        button.textContent = '复制';
                        button.classList.remove('copied');
                    }, 3000);
                }).catch(function(err) {
                    console.error('复制失败: ', err);
                    button.textContent = '失败';
                    setTimeout(function() {
                        button.textContent = '复制';
                    }, 3000);
                });
            });

            block.appendChild(button);
        });

        const allPreBlocks = document.querySelectorAll('pre:not(.mermaid)');
        allPreBlocks.forEach(function(block) {
            if (block.closest('.sourceCode') || block.querySelector('.copy-button')) return;

            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = '复制';
            button.setAttribute('aria-label', '复制代码');

            button.addEventListener('click', function() {
                const code = block.querySelector('code');
                const text = code ? code.innerText : block.innerText;

                navigator.clipboard.writeText(text).then(function() {
                    button.textContent = '已复制';
                    button.classList.add('copied');

                    setTimeout(function() {
                        button.textContent = '复制';
                        button.classList.remove('copied');
                    }, 3000);
                }).catch(function(err) {
                    console.error('复制失败: ', err);
                    button.textContent = '失败';
                    setTimeout(function() {
                        button.textContent = '复制';
                    }, 3000);
                });
            });

            block.appendChild(button);
        });
    }

    // 生成文章目录
    function generateTableOfContents() {
        const postContent = document.getElementById('post-content');
        const tocNav = document.getElementById('toc-nav');

        if (!postContent || !tocNav) {
            console.log('Missing postContent or tocNav element');
            return;
        }

        // 查找所有标题元素
        const headings = postContent.querySelectorAll('h1, h2, h3, h4, h5, h6');
        console.log('Found headings:', headings.length);

        if (headings.length === 0) {
            // 如果没有标题，隐藏目录
            console.log('No headings found, hiding TOC');
            const tocSidebar = document.getElementById('toc-sidebar');
            if (tocSidebar) tocSidebar.style.display = 'none';
            return;
        }

        // 清空目录容器
        tocNav.innerHTML = '';

        // 创建目录结构
        const tocList = document.createElement('ul');
        tocList.className = 'toc-list';

        let currentLevel = 1;
        let currentList = tocList;
        let listStack = [tocList];

        headings.forEach((heading, index) => {
            // 强制为每个标题设置标准化的ID（始终重写现有ID）
            const normalizedId = 'heading-' + index;
            heading.id = normalizedId;

            const level = parseInt(heading.tagName.charAt(1));
            const title = heading.textContent.trim();

            // 创建目录项
            const tocItem = document.createElement('li');
            tocItem.className = 'toc-item toc-level-' + level;

            const tocLink = document.createElement('a');
            tocLink.href = 'javascript:void(0)'; // 避免触发路由
            tocLink.setAttribute('data-target', heading.id); // 存储目标ID
            tocLink.textContent = title;
            tocLink.className = 'toc-link';

            tocItem.appendChild(tocLink);

            // 处理层级关系
            if (level > currentLevel) {
                // 创建新的子列表
                const newList = document.createElement('ul');
                newList.className = 'toc-sublist';
                // 检查是否有父元素
                const parentList = listStack[listStack.length - 1];
                if (parentList.lastElementChild) {
                    parentList.lastElementChild.appendChild(newList);
                } else {
                    // 如果没有父元素，直接添加到当前列表
                    parentList.appendChild(newList);
                }
                listStack.push(newList);
                currentList = newList;
            } else if (level < currentLevel) {
                // 返回到上一级
                while (listStack.length > level) {
                    listStack.pop();
                }
                currentList = listStack[listStack.length - 1];
            }

            currentList.appendChild(tocItem);
            currentLevel = level;
        });

        tocNav.appendChild(tocList);
        console.log('TOC generated successfully');

        // 高亮当前章节
        highlightCurrentSection();

        // 滚动监听
        window.addEventListener('scroll', highlightCurrentSection);

        // 为目录链接添加点击事件
        setTimeout(() => {
            const tocLinks = document.querySelectorAll('.toc-link');
            tocLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute('data-target');
                    if (targetId) {
                        const targetElement = document.getElementById(targetId);
                        if (targetElement) {
                            targetElement.scrollIntoView({
                                behavior: 'smooth',
                                block: 'start',
                                inline: 'nearest'
                            });
                        }
                    }
                });
            });
        }, 200); // 延迟确保目录已生成
    }

    // 高亮当前阅读的章节
    function highlightCurrentSection() {
        const headings = document.querySelectorAll('.post-content h1, .post-content h2, .post-content h3, .post-content h4, .post-content h5, .post-content h6');
        const tocLinks = document.querySelectorAll('.toc-link');

        let currentHeading = null;
        const scrollPosition = window.pageYOffset + 100;

        // 找到当前可见的标题
        for (let i = headings.length - 1; i >= 0; i--) {
            if (headings[i].offsetTop <= scrollPosition) {
                currentHeading = headings[i];
                break;
            }
        }

        // 清除所有活动状态
        tocLinks.forEach(link => link.classList.remove('active'));

        // 高亮当前章节
        if (currentHeading) {
            const activeLink = document.querySelector('.toc-link[data-target="' + currentHeading.id + '"]');
            if (activeLink) {
                activeLink.classList.add('active');
            }
        }
    }

    // Initialize copy buttons and TOC after content loads
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loading, initializing...');
            addCopyButtons();
            setTimeout(generateTableOfContents, 100); // 延迟生成以确保内容已加载
        });
    } else {
        console.log('DOM already loaded, initializing...');
        addCopyButtons();
        setTimeout(generateTableOfContents, 100);
    }
</script>
