<style>
    .toc-sidebar {
        position: sticky;
        float: right;
        width: 280px;
        max-height: calc(100vh - 150px);
        overflow-y: auto;
        margin: 0 0 20px 30px;
        padding: 15px;
        background: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-size: 0.9rem;
        z-index: 10;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .toc-sidebar-title {
        font-weight: bold;
        margin-bottom: 12px;
        padding-bottom: 10px;
        border-bottom: 2px solid var(--secondary-color);
        font-size: 0.95rem;
    }

    .toc-sidebar ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    .toc-sidebar ul ul {
        margin: 0;
        padding-left: 16px;
    }

    .toc-sidebar li {
        margin: 8px 0;
    }

    .toc-sidebar a {
        color: var(--secondary-color);
        text-decoration: none;
        transition: color 0.2s;
        font-weight: 500;
    }

    .toc-sidebar a:hover {
        color: var(--accent-color);
        text-decoration: underline;
    }

    .toc-sidebar::-webkit-scrollbar {
        width: 6px;
    }

    .toc-sidebar::-webkit-scrollbar-track {
        background: transparent;
    }

    .toc-sidebar::-webkit-scrollbar-thumb {
        background: var(--secondary-color);
        border-radius: 3px;
    }

    .toc-sidebar::-webkit-scrollbar-thumb:hover {
        background: var(--accent-color);
    }

    @media (max-width: 1200px) {
        .toc-sidebar {
            display: none !important;
        }
    }
</style>

<article class="post">
    <header class="post-header">
        <h1 class="post-title">数据库排序中的 NULL 值：深入解析与实战指南</h1>
        <div class="post-meta">
            <div class="post-date">2025/9/2</div>
            <div class="post-category">2025-09</div>
        </div>
    </header>
    <div class="warning">
        ⚠️ 注意：此内容由 AI 协助生成，准确性未经验证，请谨慎使用
    </div>
    <div class="toc-sidebar" id="toc-container" style="display: none;">
        <div class="toc-sidebar-title">目录</div>
        <div id="toc-content"></div>
    </div>
    <div class="post-content" id="post-content">
        <h1 id="数据库排序中的-null-值深入解析与实战指南">数据库排序中的 NULL
值：深入解析与实战指南</h1>
<h2 id="摘要">摘要</h2>
<p>本文深入探讨数据库排序中 <code>NULL</code>
值的处理机制，揭示不同数据库系统的默认行为差异及背后的设计哲学。通过示例代码、可视化图表和实战案例，帮助开发者理解
<code>NULL</code>
排序的原理、陷阱及优化方法，适合数据库管理员、后端工程师及 SQL
使用者。</p>
<h2 id="目录">目录</h2>
<ul>
<li><a href="#1-核心概念null-与排序的哲学">1. 核心概念：NULL
与排序的哲学</a></li>
<li><a href="#2-数据库实现差异与底层逻辑">2.
数据库实现差异与底层逻辑</a></li>
<li><a href="#3-跨语言框架的排序实现对比">3.
跨语言/框架的排序实现对比</a></li>
<li><a href="#4-实战案例spring-data-jpa-中的排序控制">4.
实战案例：Spring Data JPA 中的排序控制</a></li>
<li><a href="#5-常见陷阱与解决方案">5. 常见陷阱与解决方案</a></li>
<li><a href="#6-总结">6. 总结</a></li>
<li><a href="#延伸阅读">延伸阅读</a></li>
<li><a href="#一句话记忆">一句话记忆</a></li>
</ul>
<hr />
<h2 id="核心概念null-与排序的哲学">1. 核心概念：NULL 与排序的哲学</h2>
<h3 id="概念解释">概念解释</h3>
<p>在关系型数据库中，<code>NULL</code>
表示<strong>缺失或未定义的数据</strong>，而非零值或空字符串。排序时，<code>NULL</code>
的归属成为关键问题： - <strong>历史背景</strong>：SQL 标准未强制规定
<code>NULL</code> 排序行为，导致不同数据库实现差异。 -
<strong>设计动机</strong>：<code>NULL</code>
应视为“未知”，因此无法与其他值比较大小（如 <code>NULL &gt; 1</code> 返回
<code>UNKNOWN</code>）。</p>
<h3 id="示例代码">示例代码</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 创建测试表</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> employees (</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">id</span> <span class="dt">INT</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    name <span class="dt">VARCHAR</span>(<span class="dv">50</span>),</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    salary <span class="dt">DECIMAL</span>(<span class="dv">10</span>,<span class="dv">2</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">INSERT</span> <span class="kw">INTO</span> employees <span class="kw">VALUES</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="st">&#39;Alice&#39;</span>, <span class="dv">5000</span>),</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span>, <span class="st">&#39;Bob&#39;</span>, <span class="kw">NULL</span>),</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>(<span class="dv">3</span>, <span class="st">&#39;Charlie&#39;</span>, <span class="dv">7000</span>);</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- 默认排序（NULL 行为因数据库而异）</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="op">*</span> <span class="kw">FROM</span> employees <span class="kw">ORDER</span> <span class="kw">BY</span> salary <span class="kw">ASC</span>;</span></code></pre></div>
<h3 id="mermaid-图null-排序逻辑">Mermaid 图：NULL 排序逻辑</h3>
<pre class="mermaid">graph TD
    A[排序请求] --&gt; B{列是否包含 NULL?}
    B -- 是 --&gt; C[数据库默认行为]
    C --&gt; D[NULL 在前 (ASC)]
    C --&gt; E[NULL 在后 (ASC)]
    B -- 否 --&gt; F[常规排序]</pre>
<h3 id="问题分析">问题分析</h3>
<ul>
<li><strong>误区</strong>：认为 <code>NULL</code>
是“最小值”或“最大值”。</li>
<li><strong>边界情况</strong>：<code>NULL</code> 与 <code>NULL</code>
比较时，结果为 <code>UNKNOWN</code>（非 <code>TRUE</code> 或
<code>FALSE</code>）。</li>
</ul>
<h3 id="应用场景">应用场景</h3>
<ul>
<li>报表生成时需隐藏未填写的字段（将 <code>NULL</code> 排至末尾）。</li>
<li>数据清洗阶段需优先处理缺失值（将 <code>NULL</code> 排至开头）。</li>
</ul>
<hr />
<h2 id="数据库实现差异与底层逻辑">2. 数据库实现差异与底层逻辑</h2>
<h3 id="概念解释-1">概念解释</h3>
<p>不同数据库对 <code>NULL</code> 的默认排序行为不同： | 数据库 |
<code>ASC</code> 默认行为 | <code>DESC</code> 默认行为 | 显式控制语法 |
|————-|—————-|—————–|———————-| | PostgreSQL | NULL 在后 | NULL 在前 |
<code>NULLS FIRST/LAST</code> | | MySQL | NULL 在前 | NULL 在后 |
<code>ISNULL()</code> + <code>ORDER</code> | | Oracle | NULL 在后 | NULL
在前 | <code>NULLS FIRST/LAST</code> | | SQL Server | NULL 在前 | NULL
在后 | 无原生支持，需 <code>CASE</code>|</p>
<h3 id="示例代码显式控制">示例代码（显式控制）</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- PostgreSQL/Oracle: 强制 NULL 在前</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="op">*</span> <span class="kw">FROM</span> employees <span class="kw">ORDER</span> <span class="kw">BY</span> salary <span class="kw">ASC</span> <span class="kw">NULLS</span> <span class="fu">FIRST</span>;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- MySQL: 使用函数控制</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="op">*</span> <span class="kw">FROM</span> employees <span class="kw">ORDER</span> <span class="kw">BY</span> ISNULL(salary), salary <span class="kw">ASC</span>;</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- SQL Server: 使用 CASE 表达式</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="op">*</span> <span class="kw">FROM</span> employees <span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">CASE</span> <span class="cf">WHEN</span> salary <span class="kw">IS</span> <span class="kw">NULL</span> <span class="cf">THEN</span> <span class="dv">0</span> <span class="cf">ELSE</span> <span class="dv">1</span> <span class="cf">END</span>, salary <span class="kw">ASC</span>;</span></code></pre></div>
<h3 id="mermaid-图跨数据库行为对比">Mermaid 图：跨数据库行为对比</h3>
<pre class="mermaid">pie
    title NULL 排序默认行为 (ASC)
    &quot;PostgreSQL: NULL 在后&quot; : 25
    &quot;MySQL: NULL 在前&quot; : 25
    &quot;Oracle: NULL 在后&quot; : 25
    &quot;SQL Server: NULL 在前&quot; : 25</pre>
<h3 id="问题分析-1">问题分析</h3>
<ul>
<li><strong>陷阱</strong>：跨数据库迁移时未显式指定 <code>NULL</code>
顺序，导致排序结果不一致。</li>
<li><strong>性能</strong>：<code>CASE</code> 表达式在 SQL Server
中可能影响索引使用。</li>
</ul>
<h3 id="应用场景-1">应用场景</h3>
<ul>
<li>多数据库兼容的 ETL 工具需显式指定 <code>NULL</code> 顺序。</li>
<li>微服务架构中，不同服务使用不同数据库时需统一排序逻辑。</li>
</ul>
<hr />
<h2 id="跨语言框架的排序实现对比">3. 跨语言/框架的排序实现对比</h2>
<h3 id="概念解释-2">概念解释</h3>
<p>应用层排序（如 Java、Python）与数据库排序的 <code>NULL</code>
处理差异： | 语言/框架 | 默认行为 | 显式控制方法 |
|———–|—————-|———————————-| | Java | NULL 抛出异常 |
<code>Comparator.nullsFirst()/Last()</code> | | Python | NULL
视为最小值| <code>sorted(..., key=lambda x: (x is None, x))</code> | |
JavaScript| <code>undefined</code> 排最后 |
<code>arr.sort((a,b) =&gt; (a === undefined) - (b === undefined) || a-b)</code>
|</p>
<h3 id="示例代码-1">示例代码</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Java: 使用 Comparator 控制 NULL</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">List</span><span class="op">&lt;</span>Employee<span class="op">&gt;</span> sorted <span class="op">=</span> employees<span class="op">.</span><span class="fu">stream</span><span class="op">()</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">sorted</span><span class="op">(</span><span class="bu">Comparator</span><span class="op">.</span><span class="fu">nullsFirst</span><span class="op">(</span><span class="bu">Comparator</span><span class="op">.</span><span class="fu">comparing</span><span class="op">(</span>Employee<span class="op">::</span>getSalary<span class="op">)))</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">collect</span><span class="op">(</span>Collectors<span class="op">.</span><span class="fu">toList</span><span class="op">());</span></span></code></pre></div>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Python: 元组排序控制 NULL</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>sorted_employees <span class="op">=</span> <span class="bu">sorted</span>(employees, key<span class="op">=</span><span class="kw">lambda</span> x: (x.salary <span class="kw">is</span> <span class="va">None</span>, x.salary))</span></code></pre></div>
<h3 id="mermaid-图java-与-python-的-null-排序逻辑">Mermaid 图：Java 与
Python 的 NULL 排序逻辑</h3>
<pre class="mermaid">flowchart LR
    Java --&gt;|NULL 抛出异常| A[需显式指定 nullsFirst/NullsLast]
    Python --&gt;|NULL 视为最小值| B[需元组排序 (is None, value)]</pre>
<h3 id="问题分析-2">问题分析</h3>
<ul>
<li><strong>误区</strong>：认为数据库和应用层 <code>NULL</code>
排序行为一致。</li>
<li><strong>性能</strong>：应用层排序需加载全部数据，大数据量时效率低下。</li>
</ul>
<h3 id="应用场景-2">应用场景</h3>
<ul>
<li>微服务中，数据库排序后需应用层二次排序（如分页后过滤）。</li>
<li>多数据源聚合时，统一 <code>NULL</code> 排序逻辑。</li>
</ul>
<hr />
<h2 id="实战案例spring-data-jpa-中的排序控制">4. 实战案例：Spring Data
JPA 中的排序控制</h2>
<h3 id="概念解释-3">概念解释</h3>
<p>Spring Data JPA 通过 <code>Sort</code> 和 <code>Order</code>
类控制排序，但需注意 <code>NULL</code> 处理： -
<strong>默认行为</strong>：依赖底层数据库。 -
<strong>显式控制</strong>：需使用 <code>@Query</code> 自定义 SQL。</p>
<h3 id="示例代码-2">示例代码</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 方法1: 通过 Sort 对象（依赖数据库默认行为）</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>Page<span class="op">&lt;</span>Employee<span class="op">&gt;</span> page <span class="op">=</span> employeeRepository<span class="op">.</span><span class="fu">findAll</span><span class="op">(</span>PageRequest<span class="op">.</span><span class="fu">of</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> Sort<span class="op">.</span><span class="fu">by</span><span class="op">(</span><span class="st">&quot;salary&quot;</span><span class="op">).</span><span class="fu">ascending</span><span class="op">()));</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 方法2: 自定义查询（显式控制 NULL）</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="at">@Query</span><span class="op">(</span><span class="st">&quot;SELECT e FROM Employee e ORDER BY CASE WHEN e.salary IS NULL THEN 1 ELSE 0 END, e.salary ASC&quot;</span><span class="op">)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="bu">List</span><span class="op">&lt;</span>Employee<span class="op">&gt;</span> <span class="fu">findAllOrderBySalaryNullsFirst</span><span class="op">();</span></span></code></pre></div>
<h3 id="mermaid-图jpa-排序执行流程">Mermaid 图：JPA 排序执行流程</h3>
<pre class="mermaid">sequenceDiagram
    应用层-&gt;&gt;JPA: 调用 findAll(Sort)
    JPA-&gt;&gt;数据库: 生成 SQL（含 ORDER BY）
    数据库-&gt;&gt;JPA: 返回结果（NULL 按默认行为排序）
    JPA-&gt;&gt;应用层: 返回实体列表</pre>
<h3 id="问题分析-3">问题分析</h3>
<ul>
<li><strong>陷阱</strong>：未在 <code>@Query</code> 中显式处理
<code>NULL</code>，导致排序结果与预期不符。</li>
<li><strong>性能</strong>：<code>CASE</code>
表达式可能阻止索引使用，需添加函数索引。</li>
</ul>
<h3 id="应用场景-3">应用场景</h3>
<ul>
<li>分页查询中确保 <code>NULL</code>
值始终排在最后（提升用户体验）。</li>
<li>多字段排序时，对特定字段指定 <code>NULL</code>
顺序（如薪资升序，但缺失值排最后）。</li>
</ul>
<hr />
<h2 id="常见陷阱与解决方案">5. 常见陷阱与解决方案</h2>
<h3 id="陷阱-1隐式依赖默认行为">陷阱 1：隐式依赖默认行为</h3>
<ul>
<li><strong>现象</strong>：代码在 PostgreSQL 上 <code>NULL</code>
排最后，迁移到 MySQL 后排最前。</li>
<li><strong>解决方案</strong>：始终显式指定 <code>NULL</code> 顺序（如
<code>ORDER BY salary NULLS LAST</code>）。</li>
</ul>
<h3 id="陷阱-2应用层与数据库层不一致">陷阱
2：应用层与数据库层不一致</h3>
<ul>
<li><strong>现象</strong>：数据库排序后，应用层二次排序未处理
<code>NULL</code>，导致顺序错乱。</li>
<li><strong>解决方案</strong>：在应用层排序时，使用与数据库一致的
<code>NULL</code> 策略。</li>
</ul>
<h3 id="陷阱-3聚合函数中的-null">陷阱 3：聚合函数中的
<code>NULL</code></h3>
<ul>
<li><strong>现象</strong>：<code>ORDER BY AVG(salary)</code>
时，<code>NULL</code> 值影响平均值计算。</li>
<li><strong>解决方案</strong>：使用 <code>COALESCE</code> 或
<code>ISNULL</code> 处理 <code>NULL</code>（如
<code>ORDER BY AVG(COALESCE(salary, 0))</code>）。</li>
</ul>
<hr />
<h2 id="总结">6. 总结</h2>
<ul>
<li><strong>NULL 本质</strong>：表示“未知”，无法参与比较运算。</li>
<li><strong>数据库差异</strong>：PostgreSQL/Oracle 默认
<code>NULL</code> 在后，MySQL/SQL Server 默认 <code>NULL</code>
在前。</li>
<li><strong>显式控制</strong>：优先使用
<code>NULLS FIRST/LAST</code>（如 PostgreSQL）或 <code>CASE</code>
表达式（如 SQL Server）。</li>
<li><strong>应用层协调</strong>：Java 需
<code>Comparator.nullsFirst()</code>，Python 需元组排序。</li>
<li><strong>框架集成</strong>：Spring Data JPA 需 <code>@Query</code>
显式处理 <code>NULL</code>。</li>
</ul>
<h2 id="延伸阅读">延伸阅读</h2>
<ul>
<li><a
href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">SQL-92
标准文档（NULL 处理）</a></li>
<li><a
href="https://www.postgresql.org/docs/current/queries-order.html">PostgreSQL
官方文档：NULLS FIRST/LAST</a></li>
<li><a
href="https://dev.mysql.com/doc/refman/8.0/en/working-with-null.html">MySQL
官方文档：ISNULL() 函数</a></li>
<li>《SQL 经典实例》第 8 章：排序与分组</li>
</ul>
<h2 id="一句话记忆">一句话记忆</h2>
<p><strong>“NULL
是未知值，排序需显式指定顺序，跨库迁移时务必统一行为。”</strong></p>

    </div>
</article>

<script>
    // Build table of contents
    function buildTableOfContents() {
        const postContent = document.getElementById('post-content');
        const tocContainer = document.getElementById('toc-container');
        const tocContent = document.getElementById('toc-content');

        if (!postContent || !tocContainer || !tocContent) {
            return;
        }

        const headings = postContent.querySelectorAll('h2, h3, h4');
        if (headings.length === 0) {
            return;
        }

        // Assign IDs to headings
        headings.forEach((heading, index) => {
            if (!heading.id) {
                heading.id = `h-${index}`;
            }
        });

        // Build TOC items
        let tocItems = [];
        headings.forEach((heading) => {
            const level = parseInt(heading.tagName[1]);
            const text = heading.textContent.trim();
            tocItems.push({
                level: level,
                id: heading.id,
                text: text
            });
        });

        // Generate TOC HTML
        let tocHTML = '<ul>';
        let lastLevel = 1;

        tocItems.forEach((item) => {
            if (item.level > lastLevel) {
                for (let i = lastLevel; i < item.level; i++) {
                    tocHTML += '<ul>';
                }
            } else if (item.level < lastLevel) {
                for (let i = item.level; i < lastLevel; i++) {
                    tocHTML += '</li></ul>';
                }
                tocHTML += '</li>';
            } else if (lastLevel > 1) {
                tocHTML += '</li>';
            }

            tocHTML += `<li><a href="#${item.id}">${item.text}</a>`;
            lastLevel = item.level;
        });

        for (let i = 1; i < lastLevel; i++) {
            tocHTML += '</li></ul>';
        }
        if (lastLevel > 1) {
            tocHTML += '</li>';
        }
        tocHTML += '</ul>';

        tocContent.innerHTML = tocHTML;
        tocContainer.style.display = 'block';

        // Add click handlers to TOC links
        tocContent.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
    }

    // Add copy buttons to code blocks
    function addCopyButtons() {
        const sourceCodeBlocks = document.querySelectorAll('.sourceCode');
        sourceCodeBlocks.forEach(function(block) {
            if (block.querySelector('.copy-button')) return;
            const preElement = block.querySelector('pre');
            if (!preElement) return;

            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = '复制';
            button.setAttribute('aria-label', '复制代码');

            button.addEventListener('click', function() {
                const code = preElement.querySelector('code');
                const text = code ? code.innerText : preElement.innerText;

                navigator.clipboard.writeText(text).then(function() {
                    button.textContent = '已复制';
                    button.classList.add('copied');

                    setTimeout(function() {
                        button.textContent = '复制';
                        button.classList.remove('copied');
                    }, 3000);
                }).catch(function(err) {
                    console.error('复制失败: ', err);
                    button.textContent = '失败';
                    setTimeout(function() {
                        button.textContent = '复制';
                    }, 3000);
                });
            });

            block.appendChild(button);
        });

        const allPreBlocks = document.querySelectorAll('pre:not(.mermaid)');
        allPreBlocks.forEach(function(block) {
            if (block.closest('.sourceCode') || block.querySelector('.copy-button')) return;

            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = '复制';
            button.setAttribute('aria-label', '复制代码');

            button.addEventListener('click', function() {
                const code = block.querySelector('code');
                const text = code ? code.innerText : block.innerText;

                navigator.clipboard.writeText(text).then(function() {
                    button.textContent = '已复制';
                    button.classList.add('copied');

                    setTimeout(function() {
                        button.textContent = '复制';
                        button.classList.remove('copied');
                    }, 3000);
                }).catch(function(err) {
                    console.error('复制失败: ', err);
                    button.textContent = '失败';
                    setTimeout(function() {
                        button.textContent = '复制';
                    }, 3000);
                });
            });

            block.appendChild(button);
        });
    }

    // Initialize TOC and copy buttons after content loads
    window.addEventListener('load', function() {
        buildTableOfContents();
        addCopyButtons();
    });

    // Also call buildTableOfContents immediately in case content is already loaded
    document.addEventListener('DOMContentLoaded', function() {
        buildTableOfContents();
        addCopyButtons();
    });
</script>
