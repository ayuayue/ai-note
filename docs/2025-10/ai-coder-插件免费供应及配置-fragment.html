<div class="article-layout">
    <div class="main-content">
        <article class="post">
            <header class="post-header">
                <h1 class="post-title">AI代码编程插件配置与部署指南：Kilo Code免费接入实践</h1>
                <div class="post-meta">
                    <div class="post-date">2025/11/4</div>
                    <div class="post-category">2025-10</div>
                </div>
            </header>
            <div class="warning">
                ⚠️ 注意：此内容由 AI 协助生成，准确性未经验证，请谨慎使用
            </div>
            <div class="post-content" id="post-content">
                <blockquote>
<p><strong>技术指南</strong> | <em>版本：v1.0</em> |
<em>更新时间：2025-10-31</em></p>
</blockquote>
<hr />
<h2 id="目录索引">📋 目录索引</h2>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 45%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr>
<th>章节</th>
<th>内容概述</th>
<th>页码</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#1-执行摘要">1. 执行摘要</a></td>
<td>技术背景与价值分析</td>
<td>1</td>
</tr>
<tr>
<td><a href="#2-平台生态概述">2. 平台生态概述</a></td>
<td>AI编程工具发展现状</td>
<td>2</td>
</tr>
<tr>
<td><a href="#3-kilo-code插件技术架构">3. Kilo Code插件技术架构</a></td>
<td>核心功能与技术特性</td>
<td>3</td>
</tr>
<tr>
<td><a href="#4-免费api平台集成方案">4. 免费API平台集成方案</a></td>
<td>MiniMax与魔搭平台接入</td>
<td>4</td>
</tr>
<tr>
<td><a href="#5-常见问题解决">5. 常见问题解决</a></td>
<td>问题诊断与解决方案</td>
<td>5</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="执行摘要">1. 执行摘要</h2>
<h3 id="技术背景">1.1 技术背景</h3>
<p>随着人工智能技术的快速演进，代码开发领域正经历着前所未有的变革。AI辅助编程已从实验性技术发展为提升开发效率的核心工具。本指南基于2025年第四季度的最新市场调研，详细阐述了Kilo
Code插件的配置部署方法，以及MiniMax、魔搭等主流免费API平台的技术集成方案。</p>
<h3 id="核心价值">1.2 核心价值</h3>
<ul>
<li><strong>降本增效</strong>：通过免费API平台配置，降低AI编程工具的使用成本</li>
<li><strong>技术标准化</strong>：建立统一的插件配置规范和最佳实践</li>
<li><strong>可扩展性</strong>：提供多平台API接入的技术框架，支持未来扩展</li>
</ul>
<h3 id="目标受众">1.3 目标受众</h3>
<ul>
<li>软件开发工程师</li>
<li>技术架构师<br />
</li>
<li>DevOps工程师</li>
<li>AI工具运维人员</li>
</ul>
<hr />
<h2 id="平台生态概述">2. 平台生态概述</h2>
<h3 id="ai编程工具发展态势">2.1 AI编程工具发展态势</h3>
<p>当前AI编程工具市场呈现出以下特点：</p>
<pre><code>市场规模增长趋势
├── 2023年：萌芽期 - 主要工具验证
├── 2024年：成长期 - 商业化模式建立  
├── 2025年：成熟期 - 免费生态完善
└── 2026年：分化期 - 专业化细分市场</code></pre>
<h3 id="核心平台对比分析">2.2 核心平台对比分析</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>平台类型</th>
<th>代表产品</th>
<th>技术特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>闭源商业</strong></td>
<td>GitHub Copilot, Cursor</td>
<td>性能优秀，生态完善</td>
<td>企业级开发</td>
</tr>
<tr>
<td><strong>开源免费</strong></td>
<td>Kilo Code, Continue</td>
<td>开源透明，成本可控</td>
<td>个人开发者</td>
</tr>
<tr>
<td><strong>云端API</strong></td>
<td>MiniMax, 魔搭</td>
<td>按需付费，扩展性强</td>
<td>中小企业</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="kilo-code插件技术架构">3. Kilo Code插件技术架构</h2>
<h3 id="产品概述">3.1 产品概述</h3>
<p><strong>Kilo
Code</strong>是一款开源的AI代码编程助手，基于现代LLM技术栈构建，支持多种IDE环境（VSCode、IntelliJ
IDEA等）。该插件采用插件化架构设计，具有高度的可配置性和扩展性。</p>
<h4 id="核心特性">3.1.1 核心特性</h4>
<table>
<thead>
<tr>
<th>功能模块</th>
<th>技术实现</th>
<th>性能指标</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>智能代码生成</strong></td>
<td>上下文感知 + 模式匹配</td>
<td>准确率 &gt;85%</td>
</tr>
<tr>
<td><strong>实时错误诊断</strong></td>
<td>AST解析 + 规则引擎</td>
<td>延迟 &lt;200ms</td>
</tr>
<tr>
<td><strong>代码重构建议</strong></td>
<td>静态分析 + ML推理</td>
<td>建议质量 &gt;90%</td>
</tr>
<tr>
<td><strong>多模型支持</strong></td>
<td>统一接口层 + 适配器模式</td>
<td>支持20+模型</td>
</tr>
</tbody>
</table>
<h3 id="技术架构图">3.2 技术架构图</h3>
<pre><code>Kilo Code Architecture
┌─────────────────────────────────────────┐
│                UI Layer                  │
│  VSCode Extension | IntelliJ Plugin     │
├─────────────────────────────────────────┤
│               Core Engine               │
│  Prompt Manager | Context Processor     │
├─────────────────────────────────────────┤
│               API Layer                 │
│  OpenAI Compatible | Custom Adapters   │
├─────────────────────────────────────────┤
│              Platform APIs              │
│ MiniMax | 魔搭社区 | Qwen | GLM         │
└─────────────────────────────────────────┘</code></pre>
<h3 id="安装部署流程">3.3 安装部署流程</h3>
<h4 id="环境要求">3.3.1 环境要求</h4>
<table>
<thead>
<tr>
<th>组件</th>
<th>最低版本</th>
<th>推荐版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>VSCode</strong></td>
<td>1.80.0+</td>
<td>1.85.0+</td>
</tr>
<tr>
<td><strong>IntelliJ IDEA</strong></td>
<td>2023.1+</td>
<td>2024.1+</td>
</tr>
<tr>
<td><strong>Node.js</strong></td>
<td>16.0+</td>
<td>20.0+</td>
</tr>
<tr>
<td><strong>系统内存</strong></td>
<td>4GB</td>
<td>8GB+</td>
</tr>
</tbody>
</table>
<h4 id="安装步骤">3.3.2 安装步骤</h4>
<p><strong>方法一：IDE扩展商店安装</strong></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># VSCode环境</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ex">1.</span> 启动VSCode IDE</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ex">2.</span> 打开扩展管理器 <span class="er">(</span><span class="ex">Ctrl+Shift+X</span><span class="kw">)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ex">3.</span> 搜索关键词：<span class="st">&quot;Kilo Code&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ex">4.</span> 选择官方发布版本进行安装</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ex">5.</span> 重启IDE以激活插件</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># IntelliJ IDEA环境  </span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="ex">1.</span> 启动JetBrains IDE</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="ex">2.</span> 打开插件市场 <span class="er">(</span><span class="ex">Ctrl+Alt+S</span><span class="kw">)</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="ex">3.</span> 搜索：<span class="st">&quot;Kilo Code&quot;</span>  </span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="ex">4.</span> 安装并重启IDE</span></code></pre></div>
<p><strong>方法二：命令行安装</strong></p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># VSCode扩展</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ex">code</span> <span class="at">--install-extension</span> kilocode.kilo-code</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 验证安装状态</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="ex">code</span> <span class="at">--list-extensions</span> <span class="kw">|</span> <span class="fu">grep</span> kilocode</span></code></pre></div>
<h3 id="配置管理体系">3.4 配置管理体系</h3>
<p>Kilo Code采用OAuth 2.0 + API
Key的双重认证机制，首次启动时会自动引导用户完成配置。</p>
<hr />
<h2 id="免费api平台集成方案">4. 免费API平台集成方案</h2>
<h3 id="minimax开放平台">4.1 MiniMax开放平台</h3>
<h4 id="平台技术规格">4.1.1 平台技术规格</h4>
<p><strong>基础信息</strong></p>
<table>
<thead>
<tr>
<th>指标</th>
<th>数值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>模型版本</strong></td>
<td>MiniMax-M2</td>
<td>最新发布版本</td>
</tr>
<tr>
<td><strong>上下文长度</strong></td>
<td>128K tokens</td>
<td>支持长文本处理</td>
</tr>
<tr>
<td><strong>响应速度</strong></td>
<td>&lt;3s</td>
<td>平均响应时间</td>
</tr>
<tr>
<td><strong>并发支持</strong></td>
<td>100 req/min</td>
<td>免费额度限制</td>
</tr>
<tr>
<td><strong>SLA保证</strong></td>
<td>99.5%</td>
<td>服务可用性</td>
</tr>
</tbody>
</table>
<p><strong>定价策略</strong></p>
<pre><code>MiniMax-M2 定价结构
├── 输入成本：2.1元/百万tokens
├── 输出成本：8.4元/百万tokens  
├── 免费额度：新用户赠送100万tokens
└── 计费模式：按实际使用量计费</code></pre>
<h4 id="token获取流程">4.1.2 Token获取流程</h4>
<p><strong>完整操作流程</strong></p>
<pre class="mermaid">graph TD
    A[访问MiniMax开放平台] --&gt; B[点击注册按钮]
    B --&gt; C[填写邮箱密码]
    C --&gt; D[邮箱验证]
    D --&gt; E[完善个人信息]
    E --&gt; F[进入控制台]
    F --&gt; G[创建API密钥]
    G --&gt; H[复制保存密钥]</pre>
<h4 id="kilo-code集成配置">4.1.3 Kilo Code集成配置</h4>
<p><strong>配置流程图</strong></p>
<pre class="mermaid">graph TD
    A[打开Kilo Code设置] --&gt; B[选择API提供商]
    B --&gt; C[MiniMax]
    C --&gt; D[输入API配置]
    D --&gt; E[API地址: https://api.minimaxi.com/v1]
    E --&gt; F[模型: MiniMax-M2]
    F --&gt; G[粘贴API Key]
    G --&gt; H[测试连接]
    H --&gt; I[连接成功]
    H --&gt; J[连接失败]
    J --&gt; K[检查配置]
    K --&gt; D</pre>
<h3 id="魔搭社区modelscope">4.2 魔搭社区(ModelScope)</h3>
<h4 id="平台技术特性">4.2.1 平台技术特性</h4>
<p><strong>服务架构</strong></p>
<pre><code>魔搭社区技术栈
┌─────────────────────────────────┐
│          应用层                  │
│  Web界面 | API网关 | SDK工具   │
├─────────────────────────────────┤
│          服务层                  │
│ 模型推理 | 数据处理 | 任务调度 │
├─────────────────────────────────┤
│          模型层                  │
│ 开源模型 | 自研模型 | 合作模型 │
├─────────────────────────────────┤
│          基础设施层              │
│  GPU集群 | 存储系统 | 网络架构 │
└─────────────────────────────────┘</code></pre>
<p><strong>模型资源统计</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>数量</th>
<th>热门模型</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>文本生成</strong></td>
<td>500+</td>
<td>Qwen, GLM, ChatGLM</td>
<td>对话系统</td>
</tr>
<tr>
<td><strong>代码生成</strong></td>
<td>50+</td>
<td>CodeLlama, CodeT5</td>
<td>编程助手</td>
</tr>
<tr>
<td><strong>图像生成</strong></td>
<td>200+</td>
<td>Stable Diffusion</td>
<td>创意设计</td>
</tr>
<tr>
<td><strong>语音处理</strong></td>
<td>100+</td>
<td>Whisper, VALL-E</td>
<td>语音交互</td>
</tr>
<tr>
<td><strong>视频生成</strong></td>
<td>30+</td>
<td>VideoCrafter</td>
<td>内容创作</td>
</tr>
</tbody>
</table>
<h4 id="访问令牌获取">4.2.2 访问令牌获取</h4>
<p><strong>完整操作流程</strong></p>
<pre class="mermaid">graph TD
    A[访问魔搭社区] --&gt; B[用户注册登录]
    B --&gt; C[进入个人中心]
    C --&gt; D[选择令牌管理]
    D --&gt; E[创建新令牌]
    E --&gt; F[设置令牌权限]
    F --&gt; G[保存令牌信息]
    G --&gt; H[安全存储令牌]</pre>
<h4 id="kilo-code集成配置-1">4.2.3 Kilo Code集成配置</h4>
<p><strong>配置流程图</strong></p>
<pre class="mermaid">graph TD
    A[打开Kilo Code设置] --&gt; B[添加新提供商]
    B --&gt; C[选择魔搭社区]
    C --&gt; D[输入基础配置]
    D --&gt; E[API地址: https://modelscope.cn/api/v1/]
    E --&gt; F[选择模型]
    F --&gt; G[可选择列表中任意模型]
    G --&gt; H[输入访问令牌]
    H --&gt; I[测试连接]
    I --&gt; J[连接成功]
    I --&gt; K[连接失败]
    K --&gt; L[检查令牌和模型]
    L --&gt; D</pre>
<h3 id="配置对比与选择建议">4.3 配置对比与选择建议</h3>
<h4 id="平台特性对比">4.3.1 平台特性对比</h4>
<table>
<thead>
<tr>
<th>对比项目</th>
<th>MiniMax</th>
<th>魔搭社区</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>免费额度</strong></td>
<td>新用户100万tokens</td>
<td>个人用户每日2000次调用</td>
</tr>
<tr>
<td><strong>模型质量</strong></td>
<td>MiniMax-M2 (优秀)</td>
<td>多种开源模型</td>
</tr>
<tr>
<td><strong>响应速度</strong></td>
<td>&lt;3秒</td>
<td>3-8秒</td>
</tr>
<tr>
<td><strong>稳定性</strong></td>
<td>99.5% SLA</td>
<td>基础稳定</td>
</tr>
<tr>
<td><strong>易用性</strong></td>
<td>简单配置</td>
<td>需要模型选择</td>
</tr>
<tr>
<td><strong>支持语言</strong></td>
<td>中文优化</td>
<td>多语言支持</td>
</tr>
</tbody>
</table>
<h4 id="选择建议">4.3.2 选择建议</h4>
<p><strong>适合选择MiniMax的场景</strong></p>
<pre><code>✅ 优先推荐MiniMax的情况:
1. 主要开发语言为中文
2. 对响应速度要求较高
3. 偏好商业化服务稳定性
4. 需要较强的代码生成能力
5. 希望简单快速配置</code></pre>
<p><strong>适合选择魔搭社区的场景</strong></p>
<pre><code>✅ 优先推荐魔搭社区的情况:
1. 希望尝试多种开源模型
2. 对成本控制要求严格
3. 有技术调试和优化需求
4. 需要定制化模型选择
5. 偏好开源生态系统</code></pre>
<hr />
<h2 id="常见问题解决">5. 常见问题解决</h2>
<h3 id="配置相关问题">5.1 配置相关问题</h3>
<h4 id="q1-api调用返回401错误">Q1: API调用返回401错误</h4>
<p><strong>问题分析流程</strong></p>
<pre class="mermaid">graph TD
    A[收到401错误] --&gt; B{检查API Key格式}
    B --&gt;|格式错误| C[重新生成API Key]
    B --&gt;|格式正确| D{检查API Key有效性}
    D --&gt;|已过期| E[更新API Key]
    D --&gt;|权限不足| F[重新配置权限]
    E --&gt; G{验证网络连接}
    F --&gt; G
    C --&gt; G</pre>
<h4 id="q2-连接超时或响应缓慢">Q2: 连接超时或响应缓慢</h4>
<p><strong>诊断流程</strong></p>
<pre class="mermaid">graph TD
    A[响应缓慢问题] --&gt; B{检查网络连接}
    B --&gt;|网络正常| C{检查API平台状态}
    B --&gt;|网络异常| D[修复网络问题]
    C --&gt;|平台正常| E{检查配置参数}
    C --&gt;|平台异常| F[等待服务恢复]
    E --&gt;|参数正确| G[优化请求设置]
    E --&gt;|参数错误| H[调整配置参数]</pre>
<h4 id="q3-模型响应质量问题">Q3: 模型响应质量问题</h4>
<p><strong>改进策略</strong></p>
<pre class="mermaid">graph TD
    A[响应质量问题] --&gt; B{选择合适模型}
    B --&gt;|模型不当| C[更换更优模型]
    B --&gt;|模型合适| D{优化提示词}
    D --&gt;|提示词问题| E[改进提示工程]
    D --&gt;|提示词正确| F{调整生成参数}
    F --&gt;|参数不当| G[优化参数设置]
    F --&gt;|参数正确| H[检查上下文]</pre>
<h3 id="插件使用问题">5.2 插件使用问题</h3>
<h4 id="q4-插件无法启动或界面异常">Q4: 插件无法启动或界面异常</h4>
<p><strong>问题排查步骤</strong></p>
<pre class="mermaid">graph TD
    A[插件启动问题] --&gt; B{检查IDE兼容性}
    B --&gt;|版本不兼容| C[更新IDE版本]
    B --&gt;|版本兼容| D{检查插件安装}
    D --&gt;|安装异常| E[重新安装插件]
    D --&gt;|安装正常| F{检查配置冲突}
    F --&gt;|有冲突| G[清理冲突配置]
    F --&gt;|无冲突| H[重启IDE服务]</pre>
<h4 id="q5-代码补全不准确或延迟">Q5: 代码补全不准确或延迟</h4>
<p><strong>性能优化建议</strong></p>
<ol type="1">
<li><strong>系统资源优化</strong>
<ul>
<li>关闭不必要的程序</li>
<li>增加IDE内存分配</li>
<li>清理系统缓存</li>
</ul></li>
<li><strong>插件设置优化</strong>
<ul>
<li>设置合理的触发时机</li>
<li>启用本地缓存</li>
<li>限制同时请求数量</li>
</ul></li>
</ol>
<h3 id="成本控制问题">5.3 成本控制问题</h3>
<h4 id="q6-api调用成本过高">Q6: API调用成本过高</h4>
<p><strong>成本控制策略</strong></p>
<pre class="mermaid">graph TD
    A[成本控制] --&gt; B{分析使用模式}
    B --&gt;|使用过度| C[优化使用习惯]
    B --&gt;|配置不当| D[调整参数设置]
    B --&gt;|模型选择| E[选择经济模型]</pre>
<p><strong>优化措施</strong></p>
<ol type="1">
<li><strong>使用模式优化</strong>
<ul>
<li>简洁明确的问题描述</li>
<li>避免冗余的上下文</li>
<li>复用常用的提示模板</li>
</ul></li>
<li><strong>参数精细调整</strong>
<ul>
<li>代码补全: 50-100 tokens</li>
<li>代码生成: 200-500 tokens</li>
<li>代码解释: 100-200 tokens</li>
</ul></li>
</ol>
<hr />
<h2 id="总结">总结</h2>
<p>AI编程插件为现代开发提供了强有力的支持，通过合理配置和使用这些工具，可以显著提升开发效率和代码质量。</p>
<h3 id="核心要点回顾">核心要点回顾</h3>
<p><strong>技术实施</strong>： - Kilo Code插件提供统一的AI编程接口 -
支持MiniMax和魔搭等多个免费API平台 - 配置过程简单直观，适合快速部署</p>
<p><strong>平台选择</strong>： -
<strong>MiniMax</strong>：适合中文开发，响应快速，稳定性好 -
<strong>魔搭社区</strong>：适合多模型尝试，成本控制严格，技术可定制</p>
<p><strong>最佳实践</strong>： - 选择适合项目需求的API平台 -
合理配置插件参数以平衡性能和成本 - 持续优化提示工程提升输出质量 -
建立监控机制确保服务稳定性</p>
<h3 id="未来展望">未来展望</h3>
<p>随着AI技术的持续发展，免费的AI编程工具生态将不断完善。Kilo
Code作为开源项目，将持续集成更多优质API平台，为开发者提供更丰富的选择和更好的体验。</p>
<p>建议开发者： - 积极尝试新技术，保持技术敏感度 -
参与开源社区建设，共同完善工具生态 -
关注平台动态，及时更新配置和策略</p>
<p>通过合理使用这些AI辅助工具，我们能够在提升开发效率的同时，控制成本投入，实现技术价值的最大化。</p>
<hr />
<blockquote>
<p>💡
<strong>提示</strong>：建议定期关注各平台的更新公告，及时获取新功能和改进。</p>
</blockquote>
<hr />
<p><em>最后更新：2025年10月31日</em></p>

            </div>
        </article>
    </div>
    <aside class="toc-sidebar" id="toc-sidebar">
        <div class="toc-header">
            <h3>文章目录</h3>
        </div>
        <nav class="toc-nav" id="toc-nav">
            <!-- 目录内容将通过JavaScript自动生成 -->
        </nav>
    </aside>
</div>

<script>
    // Add copy buttons to code blocks
    function addCopyButtons() {
        const sourceCodeBlocks = document.querySelectorAll('.sourceCode');
        sourceCodeBlocks.forEach(function(block) {
            if (block.querySelector('.copy-button')) return;
            const preElement = block.querySelector('pre');
            if (!preElement) return;

            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = '复制';
            button.setAttribute('aria-label', '复制代码');

            button.addEventListener('click', function() {
                const code = preElement.querySelector('code');
                const text = code ? code.innerText : preElement.innerText;

                navigator.clipboard.writeText(text).then(function() {
                    button.textContent = '已复制';
                    button.classList.add('copied');

                    setTimeout(function() {
                        button.textContent = '复制';
                        button.classList.remove('copied');
                    }, 3000);
                }).catch(function(err) {
                    console.error('复制失败: ', err);
                    button.textContent = '失败';
                    setTimeout(function() {
                        button.textContent = '复制';
                    }, 3000);
                });
            });

            block.appendChild(button);
        });

        const allPreBlocks = document.querySelectorAll('pre:not(.mermaid)');
        allPreBlocks.forEach(function(block) {
            if (block.closest('.sourceCode') || block.querySelector('.copy-button')) return;

            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = '复制';
            button.setAttribute('aria-label', '复制代码');

            button.addEventListener('click', function() {
                const code = block.querySelector('code');
                const text = code ? code.innerText : block.innerText;

                navigator.clipboard.writeText(text).then(function() {
                    button.textContent = '已复制';
                    button.classList.add('copied');

                    setTimeout(function() {
                        button.textContent = '复制';
                        button.classList.remove('copied');
                    }, 3000);
                }).catch(function(err) {
                    console.error('复制失败: ', err);
                    button.textContent = '失败';
                    setTimeout(function() {
                        button.textContent = '复制';
                    }, 3000);
                });
            });

            block.appendChild(button);
        });
    }

    // 生成文章目录
    function generateTableOfContents() {
        const postContent = document.getElementById('post-content');
        const tocNav = document.getElementById('toc-nav');
        
        if (!postContent || !tocNav) return;
        
        // 查找所有标题元素
        const headings = postContent.querySelectorAll('h1, h2, h3, h4, h5, h6');
        if (headings.length === 0) {
            // 如果没有标题，隐藏目录
            document.getElementById('toc-sidebar').style.display = 'none';
            return;
        }
        
        // 创建目录结构
        const tocList = document.createElement('ul');
        tocList.className = 'toc-list';
        
        let currentLevel = 1;
        let currentList = tocList;
        let listStack = [tocList];
        
        headings.forEach((heading, index) => {
            // 强制为每个标题设置标准化的ID（始终重写现有ID）
            const normalizedId = 'heading-' + index;
            heading.id = normalizedId;
            
            const level = parseInt(heading.tagName.charAt(1));
            const title = heading.textContent.trim();
            
            // 创建目录项
            const tocItem = document.createElement('li');
            tocItem.className = 'toc-item toc-level-' + level;
            
            const tocLink = document.createElement('a');
            tocLink.href = 'javascript:void(0)'; // 避免触发路由
            tocLink.setAttribute('data-target', heading.id); // 存储目标ID
            tocLink.textContent = title;
            tocLink.className = 'toc-link';
            
            tocItem.appendChild(tocLink);
            
            // 处理层级关系
            if (level > currentLevel) {
                // 创建新的子列表
                const newList = document.createElement('ul');
                newList.className = 'toc-sublist';
                // 检查是否有父元素
                const parentList = listStack[listStack.length - 1];
                if (parentList.lastElementChild) {
                    parentList.lastElementChild.appendChild(newList);
                } else {
                    // 如果没有父元素，直接添加到当前列表
                    parentList.appendChild(newList);
                }
                listStack.push(newList);
                currentList = newList;
            } else if (level < currentLevel) {
                // 返回到上一级
                while (listStack.length > level) {
                    listStack.pop();
                }
                currentList = listStack[listStack.length - 1];
            }
            
            currentList.appendChild(tocItem);
            currentLevel = level;
        });
        
        tocNav.appendChild(tocList);
        
        // 高亮当前章节
        highlightCurrentSection();
        
        // 滚动监听
        window.addEventListener('scroll', highlightCurrentSection);
        
        // 为目录链接添加点击事件
        setTimeout(() => {
            const tocLinks = document.querySelectorAll('.toc-link');
            tocLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute('data-target');
                    if (targetId) {
                        const targetElement = document.getElementById(targetId);
                        if (targetElement) {
                            targetElement.scrollIntoView({ 
                                behavior: 'smooth', 
                                block: 'start',
                                inline: 'nearest'
                            });
                        }
                    }
                });
            });
        }, 200); // 延迟确保目录已生成
    }
    
    // 高亮当前阅读的章节
    function highlightCurrentSection() {
        const headings = document.querySelectorAll('.post-content h1, .post-content h2, .post-content h3, .post-content h4, .post-content h5, .post-content h6');
        const tocLinks = document.querySelectorAll('.toc-link');
        
        let currentHeading = null;
        const scrollPosition = window.pageYOffset + 100;
        
        // 找到当前可见的标题
        for (let i = headings.length - 1; i >= 0; i--) {
            if (headings[i].offsetTop <= scrollPosition) {
                currentHeading = headings[i];
                break;
            }
        }
        
        // 清除所有活动状态
        tocLinks.forEach(link => link.classList.remove('active'));
        
        // 高亮当前章节
        if (currentHeading) {
            const activeLink = document.querySelector('.toc-link[href="#' + currentHeading.id + '"]');
            if (activeLink) {
                activeLink.classList.add('active');
            }
        }
    }

    // Initialize copy buttons and TOC after content loads
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            addCopyButtons();
            setTimeout(generateTableOfContents, 100); // 延迟生成以确保内容已加载
        });
    } else {
        addCopyButtons();
        setTimeout(generateTableOfContents, 100);
    }
</script>